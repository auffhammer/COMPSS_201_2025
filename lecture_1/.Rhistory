shuffled_deck <- sample(deck, size = length(deck), replace = FALSE)
hand_size <- 5
hand <- shuffled_deck[1:hand_size]
print(hand)
deck <- 1:52
shuffled_deck <- sample(deck, size = length(deck), replace = FALSE)
hand_size <- 5
hand <- shuffled_deck[1:hand_size]
print(hand)
deck <- 1:52
shuffled_deck <- sample(deck, size = length(deck), replace = FALSE)
hand_size <- 5
hand <- shuffled_deck[1:hand_size]
print(hand)
deck <- 1:52
shuffled_deck <- sample(deck, size = length(deck), replace = FALSE)
hand_size <- 5
hand <- shuffled_deck[1:hand_size]
print(hand)
help(sample)
# Create a data frame
some_population_df <- data.frame(
Name = c("Shaily","Keyu","Santiago","David","Nayeli","Srishti","Chelsea","Chelsea","Kaiwen","Sang Min","Alex","Wenjia","Jerra","Citlalli","Lu","Mina","Muhammad","Shufan","Zhilie", "Eloise Wenxi", "Riza", "Iris", "Emelia", "Yuxuan", "Jonathan", "Christian", "Max", "Qinuo"),
fav_number = c(25, 30, 35, 40, 45, 30, 35, 40, 45, 30, 35, 40, 45, 30, 35, 40, 45, 30, 35, 40, 45, 30, 35, 40, 45, 30, 35, 40)
)
View(some_population_df)
View(some_population_df)
# Sample 2 rows with replacement
sampled_df <- some_population_df[sample(nrow(some_population_df), size = 3, replace = FALSE), ]
print(sampled_df)
# Sometimes we want to take repeated samples (Monte Carlo!)
# Define a population vector
k_pop <- c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)
# Replicate sampling 5 times without replacement
replicated_samples <- replicate(5, sample(k_pop, size = 3, replace = FALSE))
# Print the replicated samples
print(replicated_samples)
View(replicated_samples)
View(replicated_samples)
df %>%
filter(year == 2020) %>%
group_by(country) %>%
summarize(mean_gdp = mean(gdp, na.rm = TRUE)) %>%
arrange(desc(mean_gdp))
# Let's play with some very basic sampling strategies. Partly to make sure this R thing works on your machine or Jupyter
# Author of this crappy code: Max Auffhammer
# Date this code was written: 8/22/2025
# Clear memory
rm(list = ls())
# This next line loads a package called pacman, which will make it easier to install other packages later.
install.packages("pacman")
library(pacman)
# ggplot makes pretty graphs. dplyr is awesome. More later.
p_load(ggplot2, dplyr)
df %>%
filter(year == 2020) %>%
group_by(country) %>%
summarize(mean_gdp = mean(gdp, na.rm = TRUE)) %>%
arrange(desc(mean_gdp))
# Let's play with some very basic sampling strategies. Partly to make sure this R thing works on your machine or Jupyter
# Author of this crappy code: Max Auffhammer
# Date this code was written: 8/22/2025
# Clear memory
rm(list = ls())
# This next line loads a package called pacman, which will make it easier to install other packages later.
install.packages("pacman")
library(pacman)
# ggplot makes pretty graphs. dplyr is awesome. More later.
p_load(ggplot2, dplyr, magrittr)
library(pacman)
# ggplot makes pretty graphs. dplyr is awesome. More later.
p_load(ggplot2, dplyr, magrittr)
df %>%
filter(year == 2020) %>%
group_by(country) %>%
summarize(mean_gdp = mean(gdp, na.rm = TRUE)) %>%
arrange(desc(mean_gdp))
summarize(group_by(filter(df, year == 2020), country),
mean_gdp = mean(gdp, na.rm = TRUE))
help(filter)
df %>%
filter(year == 2020)
df
a <- df
View(a)
# Let's play with some very basic sampling strategies. Partly to make sure this R thing works on your machine or Jupyter
# Author of this crappy code: Max Auffhammer
# Date this code was written: 8/22/2025
# Clear memory
rm(list = ls())
# This next line loads a package called pacman, which will make it easier to install other packages later.
install.packages("pacman")
library(pacman)
# ggplot makes pretty graphs. dplyr is awesome. More later.
p_load(ggplot2, dplyr, magrittr, gapminder)
#Create a vector of data
#Always set seed for replicability
set.seed(09222008)
some_population <- c(100, 200, 300, 400, 500)
#Sample two values from the population with replacement
sampled_numbers <- sample (some_population, size = 2, replace = TRUE)
print(sampled_numbers)
# But what about a deck of cards? And let's do no Replacement?
deck <- 1:52
shuffled_deck <- sample(deck, size = length(deck), replace = FALSE)
hand_size <- 5
hand <- shuffled_deck[1:hand_size]
print(hand)
# Cute Max. But we are scientists. We mostly sample from data frames. How do you do that? OK.
# Create a data frame
some_population_df <- data.frame(
Name = c("Shaily","Keyu","Santiago","David","Nayeli","Srishti","Chelsea","Chelsea","Kaiwen","Sang Min","Alex","Wenjia","Jerra","Citlalli","Lu","Mina","Muhammad","Shufan","Zhilie", "Eloise Wenxi", "Riza", "Iris", "Emelia", "Yuxuan", "Jonathan", "Christian", "Max", "Qinuo"),
fav_number = c(25, 30, 35, 40, 45, 30, 35, 40, 45, 30, 35, 40, 45, 30, 35, 40, 45, 30, 35, 40, 45, 30, 35, 40, 45, 30, 35, 40)
)
# Sample 3 students' favorite number without replacement
sampled_df <- some_population_df[sample(nrow(some_population_df), size = 3, replace = FALSE), ]
print(sampled_df)
# Sometimes we want to take repeated samples (Monte Carlo!)
# Define a population vector
k_pop <- c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)
# Replicate sampling 5 times without replacement
replicated_samples <- replicate(5, sample(k_pop, size = 3, replace = FALSE))
# Print the replicated samples
print(replicated_samples)
#What about dplyr? It is an R package that makes it easier to manipulate and transform data. It’s part of the tidyverse collection of R packages, which are designed to work well together for data science tasks.
# you can do cute things with it like this.
gapminder %>%
filter(year == 2007) %>%
group_by(continent) %>%
summarize(mean_lifeExp = mean(lifeExp),
mean_gdpPercap = mean(gdpPercap)) %>%
arrange(desc(mean_gdpPercap))
# Let's play with some very basic sampling strategies. Partly to make sure this R thing works on your machine or Jupyter
# Author of this crappy code: Max Auffhammer
# Date this code was written: 8/22/2025
# Clear memory
rm(list = ls())
# This next line loads a package called pacman, which will make it easier to install other packages later.
install.packages("pacman")
library(pacman)
# ggplot makes pretty graphs. dplyr is awesome. More later.
p_load(ggplot2, dplyr, magrittr, gapminder)
#Create a vector of data
#Always set seed for replicability
set.seed(09222008)
some_population <- c(100, 200, 300, 400, 500)
#Sample two values from the population with replacement
sampled_numbers <- sample (some_population, size = 2, replace = TRUE)
print(sampled_numbers)
# But what about a deck of cards? And let's do no Replacement?
deck <- 1:52
shuffled_deck <- sample(deck, size = length(deck), replace = FALSE)
hand_size <- 5
hand <- shuffled_deck[1:hand_size]
print(hand)
# Cute Max. But we are scientists. We mostly sample from data frames. How do you do that? OK.
# Create a data frame
some_population_df <- data.frame(
Name = c("Shaily","Keyu","Santiago","David","Nayeli","Srishti","Chelsea","Chelsea","Kaiwen","Sang Min","Alex","Wenjia","Jerra","Citlalli","Lu","Mina","Muhammad","Shufan","Zhilie", "Eloise Wenxi", "Riza", "Iris", "Emelia", "Yuxuan", "Jonathan", "Christian", "Max", "Qinuo"),
fav_number = c(25, 30, 35, 40, 45, 30, 35, 40, 45, 30, 35, 40, 45, 30, 35, 40, 45, 30, 35, 40, 45, 30, 35, 40, 45, 30, 35, 40)
)
# Sample 3 students' favorite number without replacement
sampled_df <- some_population_df[sample(nrow(some_population_df), size = 3, replace = FALSE), ]
print(sampled_df)
# Sometimes we want to take repeated samples (Monte Carlo!)
# Define a population vector
k_pop <- c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)
# Replicate sampling 5 times without replacement
replicated_samples <- replicate(5, sample(k_pop, size = 3, replace = FALSE))
# Print the replicated samples
print(replicated_samples)
#What about dplyr? It is an R package that makes it easier to manipulate and transform data. It’s part of the tidyverse collection of R packages, which are designed to work well together for data science tasks.
# you can do cute things with it like this.
gapminder %>%
filter(year == 2007) %>%
group_by(continent) %>%
summarize(mean_lifeExp = mean(lifeExp),
mean_gdpPercap = mean(gdpPercap)) %>%
arrange(desc(mean_gdpPercap))
gapminder %>%
filter(year == 2007) %>%
group_by(continent) %>%
summarize(mean_lifeExp = mean(lifeExp),
mean_gdpPercap = mean(gdpPercap)) %>%
arrange(desc(mean_gdpPercap))
gapminder
library(gapminder)
p_load(ggplot2, dplyr, magrittr, gapminder)
# Let's play with some very basic sampling strategies. Partly to make sure this R thing works on your machine or Jupyter
# Author of this crappy code: Max Auffhammer
# Date this code was written: 8/22/2025
# Clear memory
rm(list = ls())
# This next line loads a package called pacman, which will make it easier to install other packages later.
install.packages("pacman")
library(pacman)
# ggplot makes pretty graphs. dplyr is awesome. More later.
p_load(ggplot2, dplyr, magrittr, gapminder)
gapminder %>%
filter(year == 2007) %>%
group_by(continent) %>%
summarize(mean_lifeExp = mean(lifeExp),
mean_gdpPercap = mean(gdpPercap)) %>%
arrange(desc(mean_gdpPercap))
cheese <- gapminder
View(cheese)
View(cheese)
gapminder
gapminder %>%
filter(year == 1973) %>%
group_by(continent) %>%
summarize(mean_lifeExp = mean(lifeExp),
mean_pop = mean(pop)) %>%
arrange(desc(pop))
gapminder %>%
filter(year == 1973) %>%
group_by(continent) %>%
summarize(mean_lifeExp = mean(lifeExp),
mean_pop = mean(pop)) %>%
arrange(desc(mean_pop))
gapminder %>%
filter(year == 1973) %>%
group_by(continent) %>%
summarize(mean_lifeExp = mean(lifeExp),
mean_gdpPercap = mean(gdpPercap)) %>%
arrange(desc(mean_gdpPercap))
gapminder %>%
filter(year == 1972) %>%
group_by(continent) %>%
summarize(mean_lifeExp = mean(lifeExp),
mean_pop = mean(pop)) %>%
arrange(desc(mean_pop))
gapminder %>%
filter(year == 1972) %>%
group_by(continent) %>%
summarize(mean_lifeExp = mean(lifeExp),
mean_pop = mean(pop)) %>%
arrange(desc(mean_pop))
set.seed(09222008)
data <- data.frame(
ID = 1:100,
Value = rnorm(100)
)
# Randomly sample 10 rows from the data frame
sampled_data <- data %>%
sample_n(10)
print(sampled_data)
help(sample_n)
sampled_data <- data %>%
sample_n(10,replace = FALSE) %>%
print(sampled_data)
sampled_data <- data %>%
sample_n(10,replace = FALSE) %>%
print
sampled_data <- data %>%
sample_n(10,replace = FALSE) %>%
print
# Let's play with some very basic sampling strategies. Partly to make sure this R thing works on your machine or Jupyter
# Author of this crappy code: Max Auffhammer
# Date this code was written: 8/22/2025
# Clear memory
rm(list = ls())
# This next line loads a package called pacman, which will make it easier to install other packages later.
install.packages("pacman")
library(pacman)
# ggplot makes pretty graphs. dplyr is awesome. More later.
p_load(ggplot2, dplyr, magrittr, gapminder)
#Create a vector of data
#Always set seed for replicability
set.seed(09222008)
some_population <- c(100, 200, 300, 400, 500)
#Sample two values from the population with replacement
sampled_numbers <- sample (some_population, size = 2, replace = TRUE)
print(sampled_numbers)
# But what about a deck of cards? And let's do no Replacement?
deck <- 1:52
shuffled_deck <- sample(deck, size = length(deck), replace = FALSE)
hand_size <- 5
hand <- shuffled_deck[1:hand_size]
print(hand)
# Cute Max. But we are scientists. We mostly sample from data frames. How do you do that? OK.
# Create a data frame
some_population_df <- data.frame(
Name = c("Shaily","Keyu","Santiago","David","Nayeli","Srishti","Chelsea","Chelsea","Kaiwen","Sang Min","Alex","Wenjia","Jerra","Citlalli","Lu","Mina","Muhammad","Shufan","Zhilie", "Eloise Wenxi", "Riza", "Iris", "Emelia", "Yuxuan", "Jonathan", "Christian", "Max", "Qinuo"),
fav_number = c(25, 30, 35, 40, 45, 30, 35, 40, 45, 30, 35, 40, 45, 30, 35, 40, 45, 30, 35, 40, 45, 30, 35, 40, 45, 30, 35, 40)
)
# Sample 3 students' favorite number without replacement
sampled_df <- some_population_df[sample(nrow(some_population_df), size = 3, replace = FALSE), ]
print(sampled_df)
# Sometimes we want to take repeated samples (Monte Carlo!)
# Define a population vector
k_pop <- c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)
# Replicate sampling 5 times without replacement
replicated_samples <- replicate(5, sample(k_pop, size = 3, replace = FALSE))
# Print the replicated samples
print(replicated_samples)
#What about dplyr? It is an R package that makes it easier to manipulate and transform data. It’s part of the tidyverse collection of R packages, which are designed to work well together for data science tasks.
# you can do cute things with it like this. Gapminder is a sample panel dataset that has info on life expectancy, population and gdp per capita by country.
# Let's take a look
cheese <- gapminder
# dplyr lets you chain tasks nicely. Say you want to figure out average life expectancy and country population by continent in 1973. You can think of %>% as "and then"....
gapminder %>%
filter(year == 1972) %>%
group_by(continent) %>%
summarize(mean_lifeExp = mean(lifeExp),
mean_pop = mean(pop)) %>%
arrange(desc(mean_pop))
set.seed(09222008)
data <- data.frame(
ID = 1:100,
Value = rnorm(100)
)
View(data)
View(data)
set.seed(09222008)
monte <- data.frame(
ID = 1:10000,
Value = rnorm(100)
)
# Can we plot the data? Yes we can?
# How about a nice histogram.
ggplot(monte, aes(x=Value, color=model, fill=model)) +
geom_vline(xintercept=0, linetype="dashed") +
geom_histogram(alpha=0.3, position="identity", bins=50) +
labs(title="IV vs. OLS",x="Coefficients", y = "Count") +
theme_classic(base_size = 15)
library(ggplot2)
set.seed(09222008)
monte <- data.frame(
ID = 1:10000,
Value = rnorm(100)
)
# Can we plot the data? Yes we can?
# How about a nice histogram.
ggplot(monte, aes(x=Value, color=model, fill=model)) +
geom_vline(xintercept=0, linetype="dashed") +
geom_histogram(alpha=0.3, position="identity", bins=50) +
labs(title="IV vs. OLS",x="Coefficients", y = "Count") +
theme_classic(base_size = 15)
ggplot(monte, aes(x=Value, color="red"", fill="model"red"")) +
ggplot(monte, aes(x=Value, color="red"", fill="model"red")) +
ggplot(monte, aes(x=Value, color="red"", fill="red")) +
ggplot(monte, aes(x=Value, color="red", fill="red")) +
geom_vline(xintercept=0, linetype="dashed") +
geom_histogram(alpha=0.3, position="identity", bins=50)
hist(data$Value)
set.seed(09222008)
monte <- data.frame(
ID = 1:10000,
Value = rnorm(100)
)
# Can we plot the data? Yes we can?
# How about a nice histogram.
ggplot(monte, aes(x=Value, color="red", fill="red")) +
geom_vline(xintercept=0, linetype="dashed") +
geom_histogram(alpha=0.3, position="identity", bins=50) +
labs(title="IV vs. OLS",x="Coefficients", y = "Count")
View(monte)
View(monte)
hist(monte$Value)
ggplot(monte, aes(x=Value, color="red")) +
geom_vline(xintercept=0, linetype="dashed") +
geom_histogram(alpha=0.3, position="identity", bins=50) +
labs(title="IV vs. OLS",x="Coefficients", y = "Count")
ggplot(monte, aes(x=Value, color="red")) +
geom_vline(xintercept=0, linetype="dashed") +
geom_histogram(alpha=0.3, bins=50) +
labs(title="IV vs. OLS",x="Coefficients", y = "Count")
ggplot(monte, aes(x=Value, color="red")) +
geom_vline(xintercept=0, linetype="dashed") +
geom_histogram(alpha=0.3) +
labs(title="IV vs. OLS",x="Coefficients", y = "Count")
set.seed(09222008)
monte <- data.frame(
ID = 1:100000,
Value = rnorm(100)
)
# Can we plot the data? Yes we can?
# How about a nice histogram.
ggplot(monte, aes(x=Value, color="red")) +
geom_vline(xintercept=0, linetype="dashed") +
geom_histogram(alpha=0.3) +
labs(title="IV vs. OLS",x="Coefficients", y = "Count")
set.seed(09222008)
monte <- data.frame(
ID = 1:100000,
Value = rnorm(100000)
)
# Can we plot the data? Yes we can?
# How about a nice histogram.
ggplot(monte, aes(x=Value, color="red")) +
geom_vline(xintercept=0, linetype="dashed") +
geom_histogram(alpha=0.3) +
labs(title="IV vs. OLS",x="Coefficients", y = "Count")
ggplot(monte, aes(x=Value, color="red",fill="blue")) +
geom_vline(xintercept=0, linetype="dashed") +
geom_histogram(alpha=0.3,bins=100) +
labs(title="Distribution of random Variable", y = "Count")
ggplot(monte, aes(x=Value, color="red",fill="blue")) +
geom_vline(xintercept=0, linetype="dashed") +
geom_histogram(alpha=0.3,bins=100) +
labs(title="Distribution of Standard Normal Random Variable", y = "Count") +
legend()
ggplot(coefficients, aes(x=Coefficient, color=model, fill=model)) +
geom_vline(xintercept=-0.8, linetype="dashed") +
geom_histogram(alpha=0.3, position="identity", bins=50) +
labs(title="IV vs. OLS",x="Coefficients", y = "Count") +
+ theme(legend.position = "none")
ggplot(monte, aes(x=Value, color="red",fill="blue")) +
geom_vline(xintercept=0, linetype="dashed") +
geom_histogram(alpha=0.3,bins=100) +
labs(title="Distribution of Standard Normal Random Variable", y = "Count") +
theme(legend.position = "none")
# Can we plot the data? Yes we can?
# How about a nice histogram.
ggplot(monte, aes(x=Value, color="red",fill="blue")) +
geom_vline(xintercept=0, linetype="dashed") +
geom_histogram(alpha=0.3,bins=100) +
labs(title="Distribution of Standard Normal Random Variable", y = "Count") +
theme(legend.position = "none")  +
theme_classic(base_size = 15)
ggplot(monte, aes(x=Value, color="red",fill="blue")) +
geom_vline(xintercept=0, linetype="dashed") +
geom_histogram(alpha=0.3,bins=100) +
labs(title="Distribution of Standard Normal Random Variable", y = "Count") +
theme(legend.position = "none")  +
theme_classic(base_size = 15)
ggplot(monte, aes(x=Value, color="red",fill="blue")) +
geom_vline(xintercept=0, linetype="dashed") +
geom_histogram(alpha=0.3,bins=100) +
labs(title="Distribution of Standard Normal Random Variable", y = "Count") +
theme_classic(base_size = 15)+
theme(legend.position = "none")
# Can we plot the data? Yes we can?
# How about a nice histogram.
ggplot(monte, aes(x=Value, color="#002676",fill="#FDB515")) +
geom_vline(xintercept=0, linetype="dashed") +
geom_histogram(alpha=0.3,bins=100) +
labs(title="Distribution of Standard Normal Random Variable", y = "Count") +
theme_classic(base_size = 15)+
theme(legend.position = "none")
ggplot(monte, aes(x=Value, color="#002676",fill="#FDB515")) +
geom_vline(xintercept=0, linetype="dashed") +
geom_histogram(alpha=0.3,bins=100) +
labs(title="Distribution of Standard Normal Random Variable", y = "Count") +
theme_classic(base_size = 15)+
theme(legend.position = "none")
ggplot(monte, aes(x=Value, color="#002676",fill="#FDB515")) +
geom_vline(xintercept=0, linetype="dashed")
+
geom_histogram(alpha=0.3,bins=100)
ggplot(monte, aes(x=Value, color="#002676",fill="#FDB515")) +
geom_vline(xintercept=0, linetype="dashed") +
geom_histogram(alpha=0.3,bins=100)
ggplot(monte, aes(x=Value, color="#002676",fill="#FDB515")) +
geom_vline(xintercept=0, linetype="dashed") +
geom_histogram(alpha=0.3,bins=100) +
labs(title="Distribution of Standard Normal Random Variable", y = "Count") +
theme_classic(base_size = 15)+
theme(legend.position = "none")
set.seed(2209)
c = 4
n = 50
# Step 1: sample 4 counties
clusters_w <- sample(unique(weather$fips), size=c, replace=FALSE)
rm(list=ls()) # Clear everything.
setwd("/Users/auffhammer/Library/CloudStorage/Dropbox/06_Teaching/MACSS/2025/COMPSS_201_2025/lecture_1")
weather <-  read.csv("lecture_1_weather.csv")
set.seed(22092008)
c = 4
n = 50
# Step 1: sample 4 counties
clusters_w <- sample(unique(weather$fips), size=c, replace=FALSE)
# Step 2: for each chosen county, draw 50 observations
sample_w <- do.call(rbind, lapply(clusters_w, function(f) {
county_data <- subset(weather, fips == f)
county_data[sample(1:nrow(county_data), size=50, replace=FALSE), ]
}))
c = 4
n = 50
# Step 1: sample 4 counties
clusters_w <- sample(unique(weather$fips), size=c, replace=FALSE)
rm(list=ls()) # Clear everything.
setwd("/Users/auffhammer/Library/CloudStorage/Dropbox/06_Teaching/MACSS/2025/COMPSS_201_2025/lecture_1")
weather <-  read.csv("lecture_1_weather.csv")
set.seed(22092008)
c = 4
n = 5
# Step 1: sample 4 counties
clusters_w <- sample(unique(weather$fips), size=c, replace=FALSE)
# Step 2: for each chosen county, draw 50 observations
sample_w <- do.call(rbind, lapply(clusters_w, function(f) {
county_data <- subset(weather, fips == f)
county_data[sample(1:nrow(county_data), size=50, replace=FALSE), ]
}))
rm(list=ls()) # Clear everything.
setwd("/Users/auffhammer/Library/CloudStorage/Dropbox/06_Teaching/MACSS/2025/COMPSS_201_2025/lecture_1")
weather <-  read.csv("lecture_1_weather.csv")
set.seed(22092008)
c = 4
n = 5
# Step 1: sample 4 counties
clusters_w <- sample(unique(weather$fips), size=c, replace=FALSE)
# Step 2: for each chosen county, draw 50 observations
sample_w <- do.call(rbind, lapply(clusters_w, function(f) {
county_data <- subset(weather, fips == f)
county_data[sample(1:nrow(county_data), size=n, replace=FALSE), ]
}))
# Check results
table(sample_w$fips)    # should show 50 for each county
nrow(sample_w)          # should be 200
mean(sample_w$tMax)
